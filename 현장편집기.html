<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>í˜„ì¥ ì‚¬ì§„ í¸ì§‘ê¸°</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #131313;
  --surf: #1e1e1e;
  --surf2: #272727;
  --surf3: #313131;
  --accent: #ff5733;
  --text: #f0f0f0;
  --text2: #888;
  --border: #383838;
}

body {
  font-family: 'Noto Sans KR', sans-serif;
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  user-select: none;
}

/* â”€â”€ ìƒë‹¨ íˆ´ë°” â”€â”€ */
#toolbar {
  background: var(--surf);
  border-bottom: 1px solid var(--border);
  padding: 8px 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  flex-shrink: 0;
}

.sep {
  width: 1px;
  height: 28px;
  background: var(--border);
  flex-shrink: 0;
}

.tool-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid transparent;
  background: transparent;
  color: var(--text2);
  cursor: pointer;
  font-family: inherit;
  font-size: 11px;
  font-weight: 500;
  transition: all 0.15s;
  white-space: nowrap;
}
.tool-btn .icon { font-size: 18px; line-height: 1; }
.tool-btn:hover { background: var(--surf3); color: var(--text); }
.tool-btn.active {
  background: var(--surf3);
  border-color: var(--accent);
  color: var(--accent);
}

.action-btn {
  padding: 7px 14px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--surf3);
  color: var(--text);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
  white-space: nowrap;
}
.action-btn:hover { background: #3d3d3d; }
.action-btn:disabled { opacity: 0.3; cursor: default; }

.btn-save {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
  margin-left: auto;
}
.btn-save:hover { background: #e04020; }

/* ìƒ‰ìƒ í”¼ì»¤ */
.color-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  font-size: 11px;
  color: var(--text2);
}
#colorPicker {
  width: 32px;
  height: 26px;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 2px;
  background: var(--surf3);
  cursor: pointer;
}

/* ì„  êµµê¸° */
.slider-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  font-size: 11px;
  color: var(--text2);
  min-width: 80px;
}
#thicknessSlider {
  width: 80px;
  accent-color: var(--accent);
  cursor: pointer;
}

/* ìˆ˜ëŸ‰ ì¹´ìš´í„° í‘œì‹œ */
#countBadge {
  background: var(--surf3);
  border: 1px solid var(--border);
  border-radius: 7px;
  padding: 4px 12px;
  font-size: 12px;
  color: var(--text2);
  white-space: nowrap;
}
#countBadge span { color: var(--accent); font-weight: 700; font-size: 14px; }

/* â”€â”€ ë©”ì¸ ì˜ì—­ â”€â”€ */
#main {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

#dropZone {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  cursor: pointer;
  transition: background 0.2s;
}
#dropZone:hover { background: #1a1a1a; }
#dropZone .drop-icon { font-size: 56px; opacity: 0.3; }
#dropZone p { color: var(--text2); font-size: 15px; }
#dropZone small { color: #555; font-size: 12px; }
#fileInput { display: none; }

/* ìº”ë²„ìŠ¤ ì˜ì—­ */
#canvasWrap {
  display: none;
  flex: 1;
  overflow: auto;
  align-items: center;
  justify-content: center;
  background: #0d0d0d;
  position: relative;
}
#canvasWrap.show { display: flex; }

#mainCanvas {
  display: block;
  max-width: 100%;
  max-height: 100%;
  cursor: crosshair;
}

/* í…ìŠ¤íŠ¸ ì¸í’‹ ì˜¤ë²„ë ˆì´ */
#textInput {
  position: fixed;
  display: none;
  z-index: 999;
  background: rgba(0,0,0,0.85);
  border: 2px solid var(--accent);
  border-radius: 6px;
  padding: 6px 10px;
  color: white;
  font-family: 'Noto Sans KR', sans-serif;
  font-size: 16px;
  outline: none;
  min-width: 120px;
}

/* íˆ´íŒ */
.tip {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.75);
  color: #ccc;
  padding: 6px 16px;
  border-radius: 20px;
  font-size: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
}
.tip.show { opacity: 1; }
</style>
</head>
<body>

<!-- ìƒë‹¨ íˆ´ë°” -->
<div id="toolbar">
  <!-- íŒŒì¼ -->
  <button class="action-btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ ì‚¬ì§„ ì—´ê¸°</button>
  <input type="file" id="fileInput" accept="image/*">

  <div class="sep"></div>

  <!-- ë„êµ¬ ë²„íŠ¼ -->
  <button class="tool-btn active" id="btn-count" onclick="setTool('count')">
    <span class="icon">ğŸ”¢</span>ìˆ˜ëŸ‰ì²´í¬
  </button>
  <button class="tool-btn" id="btn-line" onclick="setTool('line')">
    <span class="icon">â•±</span>ì§ì„ 
  </button>
  <button class="tool-btn" id="btn-arrow" onclick="setTool('arrow')">
    <span class="icon">â¡</span>í™”ì‚´í‘œ
  </button>
  <button class="tool-btn" id="btn-circle" onclick="setTool('circle')">
    <span class="icon">â­•</span>ì›
  </button>
  <button class="tool-btn" id="btn-rect" onclick="setTool('rect')">
    <span class="icon">â¬œ</span>ì‚¬ê°í˜•
  </button>
  <button class="tool-btn" id="btn-text" onclick="setTool('text')">
    <span class="icon">T</span>í…ìŠ¤íŠ¸
  </button>
  <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">
    <span class="icon">ğŸ—‘</span>ê°œë³„ì‚­ì œ
  </button>

  <div class="sep"></div>

  <!-- ìƒ‰ìƒ -->
  <div class="color-wrap">
    <input type="color" id="colorPicker" value="#ff3333">
    ìƒ‰ìƒ
  </div>

  <!-- êµµê¸° -->
  <div class="slider-wrap">
    <input type="range" id="thicknessSlider" min="1" max="20" value="3">
    êµµê¸° <span id="thicknessVal">3</span>px
  </div>

  <div class="sep"></div>

  <!-- ìˆ˜ëŸ‰ ì¹´ìš´í„° -->
  <div id="countBadge">ìˆ˜ëŸ‰ ì´ê³„: <span id="countNum">0</span>ê°œ</div>

  <div class="sep"></div>

  <!-- ë˜ëŒë¦¬ê¸° -->
  <button class="action-btn" id="undoBtn" onclick="undo()" disabled>â†© ë˜ëŒë¦¬ê¸°</button>
  <button class="action-btn" id="clearBtn" onclick="clearAll()" disabled>ğŸ—‘ ì „ì²´ì‚­ì œ</button>

  <!-- ì €ì¥ -->
  <button class="action-btn btn-save" onclick="saveImage()">ğŸ’¾ ì €ì¥</button>
</div>

<!-- ë©”ì¸ -->
<div id="main">
  <!-- ë“œë¡­ì¡´ -->
  <div id="dropZone" onclick="document.getElementById('fileInput').click()">
    <div class="drop-icon">ğŸ–¼</div>
    <p>ì‚¬ì§„ì„ í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•´ì„œ ë¶ˆëŸ¬ì˜¤ì„¸ìš”</p>
    <small>JPG, PNG, WEBP ë“± ì§€ì›</small>
  </div>

  <!-- ìº”ë²„ìŠ¤ -->
  <div id="canvasWrap">
    <canvas id="mainCanvas"></canvas>
  </div>
</div>

<!-- í…ìŠ¤íŠ¸ ì…ë ¥ -->
<input type="text" id="textInput" placeholder="í…ìŠ¤íŠ¸ ì…ë ¥ í›„ Enter">

<!-- íˆ´íŒ -->
<div class="tip" id="tip"></div>

<script>
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');
const colorPicker = document.getElementById('colorPicker');
const thicknessSlider = document.getElementById('thicknessSlider');
const thicknessVal = document.getElementById('thicknessVal');
const undoBtn = document.getElementById('undoBtn');
const clearBtn = document.getElementById('clearBtn');
const countNum = document.getElementById('countNum');
const textInputEl = document.getElementById('textInput');
const tipEl = document.getElementById('tip');

let baseImage = null;
let annotations = [];   // ëª¨ë“  ë§ˆí‚¹ ì €ì¥
let undoStack = [];     // ë˜ëŒë¦¬ê¸° ìŠ¤íƒ
let currentTool = 'count';
let countIndex = 1;
let drawing = false;
let startX, startY;
let tempAnno = null;
let textPos = null;
let canvasRect = null;
let scale = 1;

// â”€â”€ íˆ´ ì„ íƒ â”€â”€
function setTool(t) {
  currentTool = t;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + t)?.classList.add('active');
  canvas.style.cursor = t === 'eraser' ? 'pointer' : 'crosshair';
  const tips = {
    count: 'ì‚¬ì§„ì˜ ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ë©´ ë²ˆí˜¸ê°€ ì°í˜€ìš”',
    line: 'í´ë¦­ í›„ ë“œë˜ê·¸í•´ì„œ ì§ì„ ì„ ê·¸ìœ¼ì„¸ìš”',
    arrow: 'í´ë¦­ í›„ ë“œë˜ê·¸í•´ì„œ í™”ì‚´í‘œë¥¼ ê·¸ìœ¼ì„¸ìš”',
    circle: 'í´ë¦­ í›„ ë“œë˜ê·¸í•´ì„œ ì›ì„ ê·¸ìœ¼ì„¸ìš”',
    rect: 'í´ë¦­ í›„ ë“œë˜ê·¸í•´ì„œ ì‚¬ê°í˜•ì„ ê·¸ìœ¼ì„¸ìš”',
    text: 'ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ í´ë¦­í•´ì„œ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”',
    eraser: 'ì‚­ì œí•  ë§ˆí‚¹ì„ í´ë¦­í•˜ì„¸ìš”',
  };
  showTip(tips[t]);
}

function showTip(msg) {
  tipEl.textContent = msg;
  tipEl.classList.add('show');
  clearTimeout(tipEl._t);
  tipEl._t = setTimeout(() => tipEl.classList.remove('show'), 3000);
}

// â”€â”€ ìŠ¬ë¼ì´ë” â”€â”€
thicknessSlider.addEventListener('input', () => {
  thicknessVal.textContent = thicknessSlider.value;
});

// â”€â”€ íŒŒì¼ ì—´ê¸° â”€â”€
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (file) loadImage(file);
});

const dropZone = document.getElementById('dropZone');
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.background = '#1f1f1f'; });
dropZone.addEventListener('dragleave', () => { dropZone.style.background = ''; });
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.style.background = '';
  const file = e.dataTransfer.files[0];
  if (file && file.type.startsWith('image/')) loadImage(file);
});

function loadImage(file) {
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      baseImage = img;
      canvas.width = img.width;
      canvas.height = img.height;
      annotations = [];
      undoStack = [];
      countIndex = 1;
      updateCountBadge();
      dropZone.style.display = 'none';
      document.getElementById('canvasWrap').classList.add('show');
      redraw();
      updateButtons();
      canvasRect = canvas.getBoundingClientRect();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

// â”€â”€ ì¢Œí‘œ ê³„ì‚° â”€â”€
function getPos(e) {
  canvasRect = canvas.getBoundingClientRect();
  scale = canvas.width / canvasRect.width;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return {
    x: (clientX - canvasRect.left) * scale,
    y: (clientY - canvasRect.top) * scale
  };
}

// â”€â”€ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ â”€â”€
canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', e => { e.preventDefault(); onDown(e); }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e); }, { passive: false });
canvas.addEventListener('touchend', e => { e.preventDefault(); onUp(e); }, { passive: false });

function onDown(e) {
  if (!baseImage) return;
  const pos = getPos(e);

  if (currentTool === 'text') {
    textPos = pos;
    showTextInput(e);
    return;
  }

  if (currentTool === 'eraser') {
    eraseAt(pos);
    return;
  }

  if (currentTool === 'count') {
    saveUndo();
    annotations.push({
      type: 'count',
      x: pos.x, y: pos.y,
      num: countIndex++,
      color: colorPicker.value,
      size: parseInt(thicknessSlider.value) + 12
    });
    updateCountBadge();
    redraw();
    updateButtons();
    return;
  }

  drawing = true;
  startX = pos.x;
  startY = pos.y;
}

function onMove(e) {
  if (!drawing) return;
  const pos = getPos(e);
  tempAnno = {
    type: currentTool,
    x1: startX, y1: startY,
    x2: pos.x, y2: pos.y,
    color: colorPicker.value,
    thickness: parseInt(thicknessSlider.value)
  };
  redraw();
  drawAnno(tempAnno, true);
}

function onUp(e) {
  if (!drawing) return;
  drawing = false;
  if (tempAnno) {
    saveUndo();
    annotations.push({ ...tempAnno });
    tempAnno = null;
    redraw();
    updateButtons();
  }
}

// â”€â”€ í…ìŠ¤íŠ¸ ì…ë ¥ â”€â”€
function showTextInput(e) {
  canvasRect = canvas.getBoundingClientRect();
  scale = canvas.width / canvasRect.width;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  textInputEl.style.display = 'block';
  textInputEl.style.left = clientX + 'px';
  textInputEl.style.top = (clientY - 40) + 'px';
  textInputEl.style.fontSize = (parseInt(thicknessSlider.value) * 3 + 12) + 'px';
  textInputEl.style.color = colorPicker.value;
  textInputEl.value = '';
  textInputEl.focus();
}

textInputEl.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    const txt = textInputEl.value.trim();
    if (txt && textPos) {
      saveUndo();
      annotations.push({
        type: 'text',
        x: textPos.x, y: textPos.y,
        text: txt,
        color: colorPicker.value,
        size: parseInt(thicknessSlider.value) * 3 + 14
      });
      redraw();
      updateButtons();
    }
    textInputEl.style.display = 'none';
    textInputEl.value = '';
  }
  if (e.key === 'Escape') {
    textInputEl.style.display = 'none';
    textInputEl.value = '';
  }
});

// â”€â”€ ê°œë³„ ì‚­ì œ â”€â”€
function eraseAt(pos) {
  // ê°€ì¥ ê°€ê¹Œìš´ ë§ˆí‚¹ ì°¾ì•„ ì‚­ì œ
  let closest = -1;
  let minDist = 30 * (canvas.width / (canvasRect?.width || canvas.width)); // íˆíŠ¸ ì˜ì—­

  for (let i = annotations.length - 1; i >= 0; i--) {
    const a = annotations[i];
    let dist = Infinity;

    if (a.type === 'count' || a.type === 'text') {
      dist = Math.hypot(pos.x - a.x, pos.y - a.y);
    } else {
      // ì„ ë¶„ ê¸°ë°˜ (ì¤‘ê°„ì  ê¸°ì¤€ ê°„ë‹¨ ì²˜ë¦¬)
      const mx = (a.x1 + a.x2) / 2;
      const my = (a.y1 + a.y2) / 2;
      dist = Math.hypot(pos.x - mx, pos.y - my);
    }

    if (dist < minDist) {
      minDist = dist;
      closest = i;
    }
  }

  if (closest !== -1) {
    saveUndo();
    // ìˆ˜ëŸ‰ì²´í¬ ì‚­ì œì‹œ ë²ˆí˜¸ ì¬ì •ë ¬
    const deleted = annotations[closest];
    annotations.splice(closest, 1);
    if (deleted.type === 'count') reindexCounts();
    redraw();
    updateCountBadge();
    updateButtons();
  }
}

function reindexCounts() {
  let n = 1;
  for (let a of annotations) {
    if (a.type === 'count') a.num = n++;
  }
  countIndex = n;
}

// â”€â”€ ë˜ëŒë¦¬ê¸° â”€â”€
function saveUndo() {
  undoStack.push(JSON.stringify({ annotations, countIndex }));
  if (undoStack.length > 50) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  const prev = JSON.parse(undoStack.pop());
  annotations = prev.annotations;
  countIndex = prev.countIndex;
  redraw();
  updateCountBadge();
  updateButtons();
}

function clearAll() {
  if (annotations.length === 0) return;
  saveUndo();
  annotations = [];
  countIndex = 1;
  redraw();
  updateCountBadge();
  updateButtons();
}

function updateButtons() {
  undoBtn.disabled = undoStack.length === 0;
  clearBtn.disabled = annotations.length === 0;
}

function updateCountBadge() {
  const cnt = annotations.filter(a => a.type === 'count').length;
  countNum.textContent = cnt;
}

// â”€â”€ ê·¸ë¦¬ê¸° â”€â”€
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (baseImage) ctx.drawImage(baseImage, 0, 0);
  for (const a of annotations) drawAnno(a, false);
}

function drawAnno(a, isTemp) {
  ctx.save();
  ctx.globalAlpha = isTemp ? 0.7 : 1;

  if (a.type === 'count') {
    const r = a.size || 16;
    // ì›
    ctx.beginPath();
    ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
    ctx.fillStyle = a.color;
    ctx.fill();
    // í…Œë‘ë¦¬
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // ìˆ«ì
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.round(r * 1.1)}px Noto Sans KR`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(a.num, a.x, a.y);

  } else if (a.type === 'line') {
    ctx.beginPath();
    ctx.moveTo(a.x1, a.y1);
    ctx.lineTo(a.x2, a.y2);
    ctx.strokeStyle = a.color;
    ctx.lineWidth = a.thickness;
    ctx.lineCap = 'round';
    ctx.stroke();

  } else if (a.type === 'arrow') {
    drawArrow(a.x1, a.y1, a.x2, a.y2, a.color, a.thickness);

  } else if (a.type === 'circle') {
    const rx = Math.abs(a.x2 - a.x1) / 2;
    const ry = Math.abs(a.y2 - a.y1) / 2;
    const cx = (a.x1 + a.x2) / 2;
    const cy = (a.y1 + a.y2) / 2;
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx || 1, ry || 1, 0, 0, Math.PI * 2);
    ctx.strokeStyle = a.color;
    ctx.lineWidth = a.thickness;
    ctx.stroke();

  } else if (a.type === 'rect') {
    ctx.beginPath();
    ctx.strokeStyle = a.color;
    ctx.lineWidth = a.thickness;
    ctx.strokeRect(a.x1, a.y1, a.x2 - a.x1, a.y2 - a.y1);

  } else if (a.type === 'text') {
    ctx.fillStyle = a.color;
    ctx.font = `bold ${a.size}px Noto Sans KR`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    // ê·¸ë¦¼ì
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    ctx.fillText(a.text, a.x, a.y);
  }

  ctx.restore();
}

function drawArrow(x1, y1, x2, y2, color, thickness) {
  const headLen = Math.max(thickness * 4, 14);
  const angle = Math.atan2(y2 - y1, x2 - x1);

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = color;
  ctx.lineWidth = thickness;
  ctx.lineCap = 'round';
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
  ctx.strokeStyle = color;
  ctx.lineWidth = thickness;
  ctx.lineCap = 'round';
  ctx.stroke();
}

// â”€â”€ ì €ì¥ â”€â”€
function saveImage() {
  if (!baseImage) { alert('ì‚¬ì§„ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”'); return; }
  const link = document.createElement('a');
  link.download = 'í˜„ì¥í¸ì§‘_' + Date.now() + '.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// â”€â”€ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ â”€â”€
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
});

// ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆì‹œ ì¢Œí‘œ ì¬ê³„ì‚°
window.addEventListener('resize', () => {
  canvasRect = canvas.getBoundingClientRect();
});
</script>
</body>
</html>
